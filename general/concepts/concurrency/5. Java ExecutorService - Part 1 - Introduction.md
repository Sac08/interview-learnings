3 ways to create (1 more with Callable)
1.
class A extend Thread {
@Override
run() 
}

main() {
Thread t = new A();
t.start();
}
2.
class A implements Runnable {
@Override
run()
}

main() {
Thread t = new Thread(new A());
t.start();
} 

after start() new thread will be initiated

----
Why ThreadPool came into picture?

In early systems, whenever you needed to handle multiple tasks concurrently (say multiple requests to a server), the simplest approach was:
For each task → create a new thread.

This had serious drawbacks:

Expensive: Creating a thread costs memory (stack space) and CPU cycles.

Unbounded growth: If many tasks come at once, the system could spawn thousands of threads → leading to OutOfMemoryError or thrashing.

Scheduling overhead: The OS now has to context-switch between a huge number of threads, slowing everything down.

No control: You can’t limit how many threads run at once.

Example:
A web server creating a new thread per client connection → works fine for 10 clients, but dies at 10,000 clients.

2. The idea of a thread pool

Instead of creating a new thread every time, create a fixed pool of reusable threads.

Tasks are submitted to a queue.

The pool assigns tasks to available threads.

If all threads are busy, tasks wait in the queue.

Benefits:

Faster (no repeated creation/destruction)

Controlled resource usage

Scalable & stable under heavy load

Configurable (fixed, cached, scheduled)

----
whats pool size to select 
Ideal case:
If heavy CPU intense, then poolsize = cpu core
If IO heavy, more poolsize can be alloted depending on average task wait time